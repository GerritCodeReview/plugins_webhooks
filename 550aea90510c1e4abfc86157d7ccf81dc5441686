{
  "comments": [
    {
      "key": {
        "uuid": "075bdd64_bf5dc698",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2018-06-21T14:32:48Z",
      "side": 1,
      "message": "IMHO, the root cause of the issue is the design decision where Supplier.get calls EventProcessor.process. Supplier.get will first lock the supplier object and the lock\nwill be kept until EventProcessor.process returns. This can take long time when the\nremote side is slow or non-responding and other threads calling the same method on\nthat supplier will block.\n\nInstead of doing ad-hoc fixes like in this change I propose to fix the issue by making\nsure to keep object locks for shortest possible time i.e. avoid calling the process method\nwhen Supplier is locked.",
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "826c46f1_796c75ab",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2018-06-21T20:06:22Z",
      "side": 1,
      "message": "You are mostly right, yet I wouldn\u0027t call this fix ad-hoc. I have implemented toString() ad-hoc back in time (for debug purposes mostly as it was printing whole Request content) not considering that it will perform potentially heavy processing (in our implementation we are doing more than just gson.toJson() ;)) inside get() call - this is my original sin that I want to fix now :).\n\nApart from that it has nothing to do with remote site being slow/fast as processor.get(), line #72, in run() method (precisely where it belongs) happens before the connection attempt is even started. Main idea is to not recalculate it over and over again when connection is flaky as this could be (in our case is) heavy.\n\n\u003e Instead of doing ad-hoc fixes like in this change I propose to fix the issue by making\nsure to keep object locks for shortest possible time i.e. avoid calling the process method\nwhen Supplier is locked.\n\nThis is what my change is about - processor.get() stays in run() whereas toString() provides other (easily accessible) data that is enough for `show-queue` and logging purposes and doesn\u0027t interfere with it anymore.",
      "parentUuid": "075bdd64_bf5dc698",
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18630007_52165be7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2018-06-22T07:42:40Z",
      "side": 1,
      "message": "\u003e Apart from that it has nothing to do with remote site being slow/fast as processor.get(), line #72, in run() method (precisely where it belongs) happens before the connection attempt is even started.\n\nHow could a processor.get(), which as you point doesn\u0027t even open a connection to a remote\nhost, be so slow that it keeps the supplier locked such a long time that the show-queue\ncommand eventually timeouts? What are your event processors doing?\n\n\u003e This is what my change is about - processor.get() stays in run() whereas toString() provides other (easily accessible) data that is enough for `show-queue` and logging purposes and doesn\u0027t interfere with it anymore.\n\nThis may fix the issue but the original idea of reusing the supplier from toString method\nwasn\u0027t bad. Why would an processor.process() which just needs to create an HTTP request,\nnot even opening a connection, take any considerable amount of time?",
      "parentUuid": "826c46f1_796c75ab",
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "427189ea_daa1bb3f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2018-06-27T15:03:46Z",
      "side": 1,
      "message": "Long story short: it does quite expensive stuff of walking over changes between old and new rev and extracts extra info\n\nNow long story:\nRefUpdated event is pretty minimalistic in terms of content at least if you compare it to GitHUB\u0027s one [1] and it has its pros and cons.\nPros:\nit is cheap to get\n\nCons:\nIt has limited use for webhook client mainly due to the fact that one cannot easily get what update is about (I mean real data like which files were changed etc). One cannot ask Gerrit for old/new revs through API (that brings also the problem of sharing credentials). As a result one needs to clone repo and walk over to capture that data. It may seem sophisticated but in reality Jenkins faces this problem - one cannot use path based filter for RefUpdated event trigger as Jenkins is not able to decide without cloning repo first which paths were changed (and that problem applies to new Luca\u0027s jenkins plugin as the same events are used :/). IMHO we should do better for RefUpdated event and include necessary data - it may seem waste of resources/time but in reality I have already implemented RefUpdated data mining multiple times ;)\n\nHaving said that in our implementation we are building event that is very close to GitHub\u0027s push event [1] hence in some cases it takes substantial amount of time to build it.\n\nI am happy to clarify more when needed.\n\n[1] https://developer.github.com/v3/activity/events/types/#pushevent",
      "parentUuid": "18630007_52165be7",
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37da173c_4d778ddf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2018-06-27T15:27:05Z",
      "side": 1,
      "message": "1. This change doesn\u0027t make anything worse than it was before this change. Therefore,\nI am not going to CR-1 on it anymore.\n\n2. It still sound strange to me that a RevWalk, which AFAIR would most of the time\njust compare the tip of the branch with its parent commit, takes so long that it blocks\nshow-queue command long enough that it times out.",
      "parentUuid": "427189ea_daa1bb3f",
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1259002b_89fd0555",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2018-06-21T14:32:48Z",
      "side": 1,
      "message": "A thread in BLOCKED state is nothing that is bad by default.\nWhat is blocking it? Is the webhook processing thread keeping the supplier\nlocked? If yes, have you checked what is this thread doing?",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 7
      },
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "955aa873_af5304a6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2018-06-21T20:06:22Z",
      "side": 1,
      "message": "Gathering request data is taking that long in our case.",
      "parentUuid": "1259002b_89fd0555",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 7
      },
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6de21d04_dd087dc5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2018-06-21T14:32:48Z",
      "side": 1,
      "message": "What do you mean here by useless? Does this command become permanently\nuseless or is it useless because it becomes too slow?",
      "range": {
        "startLine": 30,
        "startChar": 58,
        "endLine": 30,
        "endChar": 65
      },
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afd8364f_e44300a4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2018-06-21T20:06:22Z",
      "side": 1,
      "message": "useless means that you can\u0027t check what is currently being processed in `queue` and call simply times out.",
      "parentUuid": "6de21d04_dd087dc5",
      "range": {
        "startLine": 30,
        "startChar": 58,
        "endLine": 30,
        "endChar": 65
      },
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bda2e4a7_8158539b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2018-06-21T14:08:27Z",
      "side": 1,
      "message": "Are you sure?",
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "784eeaae_d392035c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2018-06-21T14:17:44Z",
      "side": 1,
      "message": "Looking at the Guava source code I see that Suppliers.memoize returns a thread\nsafe Supplier [1]. We see that both MemoizingSupplier.get() [2] and NonSerializableMemoizingSupplier.get() [3] are coded to be thread safe.\n\nWhile you may resolved the issue with this change, I believe that the description\nof the cause of the issue in this commit message is incorrect.\n\n[1] https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Suppliers.java#L106\n[2] https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Suppliers.java#L126\n[3] https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Suppliers.java#L150",
      "parentUuid": "bda2e4a7_8158539b",
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c014aaf5_451d1a47",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2018-06-21T20:06:22Z",
      "side": 1,
      "message": "Yeah just double checked that\n\u003e The returned supplier is thread-safe.\n\nI will rephrase the reasoning.",
      "parentUuid": "784eeaae_d392035c",
      "revId": "550aea90510c1e4abfc86157d7ccf81dc5441686",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}